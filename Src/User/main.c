/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "clock.h"
#include "system_config.h"
#include "gpio.h"
#include "uart.h"


UART_HandleTypeDef huart1;

__IO uint32_t uwTick;
uint32_t uwTickPrio = (1UL << __NVIC_PRIO_BITS);

char text[20] = "Hello World!!";


void System_Clock_Config(void);
static void GPIO_Init(void);
static void UART_Init(void);


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	System_Config();

	System_Clock_Config();

	GPIO_Init();
	UART_Init();

	Delay_Ms(100);
	UART_Transmit(&huart1, (uint8_t*)text, (sizeof(text) / sizeof(text[0])), 100);

	while(1)
	{
		GPIO_Write(GPIOA, (1<<0), GPIO_SET);
		Delay_Ms(500);
		GPIO_Write(GPIOA, (1<<0), GPIO_RESET);
		Delay_Ms(500);
	}
}

void System_Clock_Config(void)
{
	OSC_ConfigSetTypeDef config = {0};
	Clock_ConfigTypeDef clock_config = {0};
	uint32_t TickStart;

	do
	{
		__IO uint32_t tmpreg;
		SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
		tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);
		UNUSED(tmpreg);
	}while(0);

	do
	{
		__IO uint32_t tmpreg;
		CLEAR_BIT(PWR->CR1, PWR_CR1_VOS);
		SET_BIT(PWR->CR1, PWR_CR1_VOS);
        tmpreg = READ_BIT(PWR->CR1, PWR_CR1_VOS);
        UNUSED(tmpreg);
	}while(0);

	config.OSC_TYPE = OSC_TYPE_HSE;
	config.HSE_SET.HSE_STATE = HSE_ON;
	config.HSI_SET.HSI_STATE = HSI_OFF;
	config.PLL_SET.PLL_STATE = PLL_ON;
	config.PLL_SET.PLLSRC = PLLSRC_HSE;
	config.PLL_SET.PLLM = 12;
	config.PLL_SET.PLLN = 216;
	config.PLL_SET.PLLP = (uint32_t)0x02U;
	config.PLL_SET.PLLQ = 9;
	if(Clock_Setup_OSC(&config) != STATE_OK)
	{
		Error_Handler();
	}

	do
	{
		__IO uint32_t tmpreg;
		SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
		tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_WWDGEN);
		UNUSED(tmpreg);
	}while(0);

	PWR->CR1 |= (uint32_t)PWR_CR1_ODEN;

	TickStart = uwTick;
	while(!((PWR->CSR1 & PWR_CSR1_ODRDY) == PWR_CSR1_ODRDY))
	{
		if((uwTick - TickStart) > 1000)
		{
			Error_Handler();
		}
	}

	PWR->CR1 |= (uint32_t)PWR_CR1_ODSWEN;

	TickStart = uwTick;
	while(!((PWR->CSR1 & PWR_CSR1_ODSWRDY) == PWR_CSR1_ODSWRDY))
	{
		if((uwTick - TickStart) > 1000)
		{
			Error_Handler();
		}
	}

	clock_config.CLOCK_TYPE = RCC_CLK_TYPE_SYSCLK | RCC_CLK_TYPE_HCLK | RCC_CLK_TYPE_PCLK1 | RCC_CLK_TYPE_PCLK2;
	clock_config.SYSCLK_SOURCE = RCC_SYSCLKSOURCE_PLLCLK;
	clock_config.AHBCLK_DIV = RCC_SYSCLK_DIV1;
	clock_config.APB1CLK_DIV = RCC_HCLK_DIV4;
	clock_config.APB2CLK_DIV = RCC_HCLK_DIV2;
	clock_config.FLatency = FLASH_ACR_LATENCY_7WS;
	if(Clock_Setup_Clock(&clock_config) != STATE_OK)
	{
		Error_Handler();
	}

	MCO_Config(RCC_MCO1, RCC_CFGR_MCO1_1, (uint32_t)0x00);


	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &= ~((3U << (13 * 2)) | (3U << (14 * 2)));
	GPIOA->MODER |= ((2U << (13 * 2)) | (2U << (14 * 2)));

	GPIOA->AFR[1] &= ~((15U << ((13 - 8) * 4)) | (15U << ((14 - 8) * 4)));
	GPIOA->AFR[1] |= ((0U << ((13 - 8) * 4)) | (0U << ((14 - 8) * 4)));

	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_SYSCFGEN);
}

static void GPIO_Init(void)
{
	GPIO_ConfigTypeDef config = {0};

	RCC_GPIOCLK_ENABLE(RCC_AHB1ENR_GPIOAEN);
	RCC_GPIOCLK_ENABLE(RCC_AHB1ENR_GPIOBEN);
	RCC_GPIOCLK_ENABLE(RCC_AHB1ENR_GPIOHEN);

	config.PIN = (1 << 8);
	config.MODE = GPIO_MODE_AF_PP;
	config.PULL = GPIO_NOPULL;
	config.SPEED = GPIO_SPEED_FREQ_HIGH;
	config.ALT = (uint8_t)0x00;

	GPIO_Config(GPIOA, &config);


	config.PIN = (1 << 0);
	config.MODE = GPIO_MODE_OUTPUT_PP;
	config.PULL = GPIO_NOPULL;
	config.SPEED = GPIO_SPEED_FREQ_LOW;

	GPIO_Config(GPIOA, &config);
}

static void UART_Init(void)
{
	huart1.INSTANCE = USART1;
	huart1.INIT.BAUD = 115200;
	huart1.INIT.WORD_LEN = 0x00U;
	huart1.INIT.STOP_BIT = 0x00U;
	huart1.INIT.PARITY = 0x00U;
	huart1.INIT.MODE = (USART_CR1_TE | USART_CR1_RE);
	huart1.INIT.FLOW_CTRL = 0x00U;
	huart1.INIT.OVER_SAMPLE = 0x00U;
	huart1.INIT.ONEB_SAMPLE = 0x00U;
	huart1.ADV_INIT.ADV_FEAT_INIT = 0x00U;
	if(UART_Config(&huart1) != STATE_OK)
	{
		Error_Handler();
	}
}

void Error_Handler(void)
{
	__disable_irq();
	while(1);
}
